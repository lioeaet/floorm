"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("react");const t={isUpdateParents:!1,arrChilds:new Map,itemsMap:new Map,descFuncs:{},stack:[],items:{},orms:{},ids:{},graph:{},childs:{},prevItems:{},nextItems:{},currentGraph:{},iterationUpdates:{}},r=(e,...t)=>r=>{const n=t.pop();return((e,...t)=>{for(const r of t)e[r]=e.hasOwnProperty(r)?e[r]:{},e=e[r];return e})(e,...t)[n]=r,r},n={},s={},o=(e,t,r)=>{const s=c(e,t),o=n[s]||(n[s]=[]);return o.push(r),()=>o.splice(o.indexOf(r),1)},i=e=>{for(let t in e)a(t)},a=e=>{const r=t.items[e],o=t.prevItems[e];if(r===o)return;const i=n[e]||[],a=s[t.orms[e].name]||[];for(let e of i)e(r,o);for(let t of a)t(r,o,e)},c=(e,n)=>(r(t.ids,e.name)(n),`${e.name}-${n}`),p=e=>u(e)&&e.id,l=e=>!(!e||!t.descFuncs[e.name]),u=e=>e&&Object.getPrototypeOf(e)===Object.prototype,d=e=>e&&"function"==typeof e.then,f=(e,t)=>e.reduce(((e,t)=>t(e)),t),h=console.log;window.z=!0,console.log=(...e)=>{h(...e),window.z=window.z&&!e.some((e=>!e))};const m=(e,r=(()=>({})))=>{if(!e)throw"orm name is required";if(t.descFuncs[e])throw"duplicate orm name "+e;return t.descFuncs[e]=r,t.orms[e]=f(g,{name:e})},g=[];m.enhance=e=>g.push(e);const y=e=>t.items[e],w=Symbol("theEnd"),x=(e,t,r,n)=>{if(e[t]||(e[t]={}),!r)return;let s=e[t];for(let e=n.indexOf(r);n.length>e;e++){const t=n[e];e===n.length-1?s[t]=w:s=s[t]||(s[t]={})}},k=(e,r,n,s)=>{if(!n)return;let o=e[r],i=o,a=n;for(let e=s.indexOf(n);s.length>e&&(o=o[s[e]],o);e++)Object.keys(o).length>1&&(i=o,a=s[e+1]);e[r]===i&&1===Object.keys(i[n]).length&&delete t.childs[n][r],delete i[a]},O=(e,t)=>{if(t===w)return e===w;if(!e)return!1;for(let r in t)if(!O(e[r],t[r]))return!1;return!0},I=(e,n,s,o)=>{const i=t.items[n],a=t.nextItems[n]||(t.nextItems[n]={});if(t.prevItems.hasOwnProperty(n)||(t.prevItems[n]=i),o){if(((e,t,r,n)=>{if(!r||!e[t])return!1;let s=e[t];for(let e=n.indexOf(r);n.length>e&&(s=s[n[e]],s);e++);return s===w})(t.currentGraph,n,o,t.stack))return a;if(x(t.currentGraph,n,o,t.stack),x(t.graph,n,o,t.stack),r(t.childs,o,n)(!0),n===o&&n!==t.stack[0])return a;if(t.isUpdateParents){if(i===a)return a;if(i===s&&!(t.childs[n]||{}).hasOwnProperty(o))return delete t.nextItems[n],i}}if(t.itemsMap.delete(i),t.itemsMap.set(a,!0),t.stack.includes(n)){for(let e in s)a.hasOwnProperty(e)||(a[e]=s[e]);return a}return t.iterationUpdates[n]=!0,t.orms[n]=e,t.stack.push(n),t.items[n]=P(t.descFuncs[e.name](),i,s,a,n),t.stack.pop(),a},P=(e,r,n,s,o)=>{if(l(e)){const s=p(n),i=p(r),a=c(e,s);if(i&&s!==i){const r=c(e,i);if(r&&o&&k(t.graph,r,o,t.stack),!n)return n}return I(e,a,n,o)}if(u(n)){for(let i in n){const a=e&&e[i],c=r&&r[i];t.stack.push(i),s[i]=P(a,c,n[i],A(n[i]),o),t.stack.pop()}if(u(r))for(let e in r)s.hasOwnProperty(e)||(s[e]=r[e]);return s}if(Array.isArray(n)){const i=e[0],a=t.arrChilds.get(r)||{},l={};for(let e=0;n.length>e;e++){const u=n[e],d=c(i,p(u)),f=a[d]||{},h=l[d]||{};if(h[e]=!0,l[d]=h,t.stack.push(e),r&&r[e]&&!f[e]){const n=c(i,p(r[e]));n&&k(t.graph,n,o,t.stack)}s[e]=I(i,d,u,o),t.stack.pop()}if(r&&r.length>n.length)for(let e=n.length;r.length>e;e++){const n=c(i,p(r[e]));t.stack.push(e),k(t.graph,n,o,t.stack),t.stack.pop(e)}return t.arrChilds.delete(r),t.arrChilds.set(s,l),s}return s},A=e=>Array.isArray(e)?[]:u(e)?{}:e,U=()=>{t.isUpdateParents=!0;for(let e in t.iterationUpdates){const r=t.graph[e];if(r)for(let n in r)if(!t.currentGraph[e]||!O(t.currentGraph[e][n],t.graph[e][n])){const r=t.items[n],s=t.orms[n],o=v(t.graph[e][n],r,e,r.id);t.iterationUpdates={},I(s,n,o),U()}}},v=(e,r,n,s)=>{const o=Array.isArray(r)?[...r]:s?{id:s}:{};for(let s in e)o[s]=e[s]===w?t.items[n]:v(e[s],r[s],n);return o},M=(e,r,n)=>(I(e,r,n),U(),i(t.nextItems),t.isUpdateParents=!1,t.nextItems={},t.currentGraph={},t.iterationUpdates={},t.prevItems={},t.items[r]),b=(e,r,n,s)=>{if(Array.isArray(r)){const e=t.items[n];return r.filter((t=>t!==e))}const o=s?{id:s}:{};for(let t in e)o[t]=e[t]===w?null:b(e[t],r[t],n);return o},G=e=>{for(let r in e){const n=e[r];Array.isArray(n)?t.arrChilds.delete(n):u(n)&&!t.itemsMap.has(n)&&G(n)}};const j=e=>({state:e,id:"stone"}),F=(e,r={})=>{r=j(r);const n=m(e,(()=>r)),s=c(n,"stone");return t.orms[e]=n,f(C,{put:e=>{if("function"==typeof e){e=e((y(s)||{}).state)}return d(e)?q(n,s,e,!0):M(n,s,j(e)).state},get:()=>{const e=y(s);return e&&e.state},loading:()=>E(s),name:e})},C=[];F.enhance=e=>C.push(e);const S={},z={},q=(e,t,r,n)=>{const s=r.then((r=>{if(S[t]!==s)throw"canceled";return delete S[t],r=n?j(r):r,M(e,t,r).state}),(e=>{if(S[t]!==s)throw"canceled";throw delete S[t],e}));return S[t]=s,$(t),s},E=e=>S.hasOwnProperty(e),$=e=>{const t=z[e]||[];for(let r of t)r(S[e])},_=e=>f(D,{put:(t,r)=>(r="function"==typeof r?r(e.get(t)):r,d(r)?q(e,c(e,t),r):M(e,c(e,t),{id:t,...r})),get:t=>y(c(e,t)),remove:r=>(e=>{const r=t.graph[e];t.isUpdateParents=!0;for(let n in r){if(e===n)continue;const s=t.items[n],o=t.orms[n],i=b(r[n],s,e,s.id);I(o,n,i)}U();const n=t.items[e];t.itemsMap.delete(n),t.prevItems[e]=n,t.items[e]=null,t.nextItems[e]=null,i(t.nextItems),t.isUpdateParents=!1,t.nextItems={},t.currentGraph={},t.iterationUpdates={},t.prevItems={};for(let r in t.childs[e]||{})delete t.graph[r][e];for(let r in t.graph[e]||{})delete t.childs[r][e];return delete t.ids[t.orms[e].name][p(n)],delete t.orms[e],delete t.childs[e],delete t.graph[e],G(n),t.itemsMap.delete(n),delete t.items[e],n.id})(c(e,r)),all:()=>(e=>Object.keys(t.ids[e.name]).map((t=>y(c(e,t)))))(e),loading:t=>E(c(e,t)),name:e.name}),D=[];_.enhance=e=>D.push(e);const B=(t,r,n)=>{const s=c(t,r),i=H(s);e.useEffect((()=>{const e=()=>n(H(s));return i!==H(s)&&e(),((e,t,r)=>{const n=c(e,t),s=z[n]||(z[n]=[]);s.push(r);const i=o(e,t,r);return()=>{i(),s.splice(s.indexOf(r),1)}})(t,r,e)}),[t,r,s,i,n])},H=e=>(e=>S[e])(e)||t.items[e],J=(e,t)=>{if(l(e))return t&&t.id;if(Array.isArray(e))return t.map((e=>e&&e.id));if(u(e)){if(!t)return t;let r={};for(let n in t)r[n]=J(e[n],t[n]);return r}return t};exports.door=_,exports.flat=(e,r)=>{const n=e.hasOwnProperty("all"),s=t.descFuncs[e.name](),o=y(c({name:e.name},n?r:"stone")),i=J(s,o);return n?i:i.state},exports.orm=m,exports.stone=F,exports.useDoor=(r,n)=>{const s=t.orms[r.name],o=c(s,n),[i,a]=e.useState(H(o));if(B(s,n,a),d(i))throw i;return i},exports.useStone=r=>{const n=t.orms[r.name],s=c(n,"stone"),[o,i]=e.useState(H(s));if(B(n,"stone",i),d(o))throw o.then((e=>e));return o&&o.state},exports.watch=(e,t)=>{const r=s[e.name]||(s[e.name]=[]);return r.push(t),()=>r.splice(r.indexOf(t),1)},exports.watchId=o;
