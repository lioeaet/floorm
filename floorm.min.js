"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("react");const t={iterationUpdates:{},arrChilds:new Map,itemsMap:new Map,descFuncs:{},stack:[],items:{},orms:{},ids:{},graph:{},childs:{},prevItems:{},nextItems:{},currentGraph:{},isUpdateParents:!1};console.log(t),window.g=t;const r=(e,r=(()=>({})))=>{if(!e)throw"orm name is required";if(t.descFuncs[e])throw"duplicate orm name "+e;return t.descFuncs[e]=r,t.orms[e]={name:e}},n=e=>t.items[e],s=(e,...t)=>{for(const r of t)e[r]=e.hasOwnProperty(r)?e[r]:{},e=e[r];return e},o=(e,...t)=>r=>{const n=t.pop();return s(e,...t)[n]=r,r},i={},a={},c=(e,t,r)=>{const n=u(e,t),s=i[n]||(i[n]=[]);return s.push(r),()=>s.splice(s.indexOf(r),1)},p=e=>{for(let t in e)l(t)},l=e=>{const r=t.items[e],n=t.prevItems[e];if(r===n)return;const s=i[e]||[],o=a[t.orms[e].name]||[];for(let e of s)e(r,n);for(let t of o)t(r,n,e)},u=(e,r)=>{const n=((e,...t)=>{const r=t.pop();return s(e,...t)[r]})(t.ids,e.name)||o(t.ids,e.name)({});return r&&!n.hasOwnProperty(r)&&o(n,r)(`${e.name}-${r}`),n[r]},d=e=>m(e)&&e.id,f=e=>!(!e||!t.descFuncs[e.name]),m=e=>e&&Object.getPrototypeOf(e)===Object.prototype,h=e=>e&&"function"==typeof e.then,g=(e,t)=>e.reduce(((e,t)=>t(e)),t),y=console.log;window.z=!0,console.log=(...e)=>{y(...e),window.z=window.z&&!e.some((e=>!e))};const w=Symbol("theEnd"),x=(e,t,r,n)=>{if(e[t]||(e[t]={}),!r)return;let s=e[t];for(let e=n.indexOf(r);n.length>e;e++){const t=n[e];e===n.length-1?s[t]=w:s=s[t]||(s[t]={})}},O=(e,r,n,s)=>{if(!n)return;let o=e[r],i=o,a=n;for(let e=s.indexOf(n);s.length>e&&(o=o[s[e]],o);e++)Object.keys(o).length>1&&(i=o,a=s[e+1]);e[r]===i&&1===Object.keys(i[n]).length&&delete t.childs[n][r],delete i[a]},k=(e,t)=>{if(t===w)return e===w;if(!e)return!1;for(let r in t)if(!k(e[r],t[r]))return!1;return!0},I=(e,r,n,s)=>{const i=t.items[r],a=t.nextItems[r]||(t.nextItems[r]={});if(t.prevItems.hasOwnProperty(r)||(t.prevItems[r]=i),s){if(((e,t,r,n)=>{if(!r||!e[t])return!1;let s=e[t];for(let e=n.indexOf(r);n.length>e&&(s=s[n[e]],s);e++);return s===w})(t.currentGraph,r,s,t.stack))return a;if(x(t.currentGraph,r,s,t.stack),x(t.graph,r,s,t.stack),o(t.childs,s,r)(!0),r===s&&r!==t.stack[0])return a;if(t.isUpdateParents){if(i===a)return a;if(i===n&&!(t.childs[r]||{}).hasOwnProperty(s))return delete t.nextItems[r],i}}if(t.itemsMap.delete(i),t.itemsMap.set(a,!0),t.stack.includes(r)){for(let e in n)a.hasOwnProperty(e)||(a[e]=n[e]);return a}return t.iterationUpdates[r]=!0,t.orms[r]=e,t.stack.push(r),t.items[r]=P(t.descFuncs[e.name](),i,n,a,r),t.stack.pop(),a},P=(e,r,n,s,o)=>{if(f(e)){const s=d(n),i=d(r),a=u(e,s);if(i&&s!==i){const r=u(e,i);if(r&&o&&O(t.graph,r,o,t.stack),!n)return n}return I(e,a,n,o)}if(m(n)){for(let i in n){const a=e&&e[i],c=r&&r[i];t.stack.push(i),s[i]=P(a,c,n[i],A(n[i]),o),t.stack.pop()}if(m(r))for(let e in r)s.hasOwnProperty(e)||(s[e]=r[e]);return s}if(Array.isArray(n)){const i=e[0],a=t.arrChilds.get(r)||{},c={};for(let e=0;n.length>e;e++){const p=n[e],l=u(i,d(p)),f=a[l]||{},m=c[l]||{};if(m[e]=!0,c[l]=m,t.stack.push(e),r&&r[e]&&!f[e]){const n=u(i,d(r[e]));n&&O(t.graph,n,o,t.stack)}s[e]=I(i,l,p,o),t.stack.pop()}if(r&&r.length>n.length)for(let e=n.length;r.length>e;e++){const n=u(i,d(r[e]));t.stack.push(e),O(t.graph,n,o,t.stack),t.stack.pop(e)}return t.arrChilds.delete(r),t.arrChilds.set(s,c),s}return s},A=e=>Array.isArray(e)?[]:m(e)?{}:e,U=()=>{t.isUpdateParents=!0;for(let e in t.iterationUpdates){const r=t.graph[e];if(r)for(let n in r)if(!t.currentGraph[e]||!k(t.currentGraph[e][n],t.graph[e][n])){const r=t.items[n],s=t.orms[n],o=v(t.graph[e][n],r,e,r.id);t.iterationUpdates={},I(s,n,o),U()}}},v=(e,r,n,s)=>{const o=Array.isArray(r)?[...r]:s?{id:s}:{};for(let s in e)o[s]=e[s]===w?t.items[n]:v(e[s],r[s],n);return o},M=(e,r,n)=>(I(e,r,n),U(),p(t.nextItems),t.isUpdateParents=!1,t.nextItems={},t.currentGraph={},t.iterationUpdates={},t.prevItems={},t.items[r]),b=(e,r,n,s)=>{if(Array.isArray(r)){const e=t.items[n];return r.filter((t=>t!==e))}const o=s?{id:s}:{};for(let t in e)o[t]=e[t]===w?null:b(e[t],r[t],n);return o},G=e=>{for(let r in e){const n=e[r];Array.isArray(n)?t.arrChilds.delete(n):m(n)&&!t.itemsMap.has(n)&&G(n)}};const j=e=>({state:e,id:"stone"}),F=(e,s={})=>{s=j(s);const o=r(e,(()=>s)),i=u(o,"stone");return t.orms[e]=o,g(C,{put:e=>{if("function"==typeof e){e=e((n(o)||{}).state)}return h(e)?q(o,i,e,!0):M(o,i,j(e))},get:()=>{const e=n(o);return e&&e.state},loading:()=>E(i),name:e})},C=[];F.enhance=e=>C.push(e);const S={},z={},q=(e,t,r,n)=>{const s=r.then((r=>{if(S[t]!==s)throw"canceled";return delete S[t],r=n?j(r):r,M(e,t,r)}),(e=>{if(S[t]!==s)throw"canceled";throw delete S[t],e}));return S[t]=s,$(t),s},E=e=>S.hasOwnProperty(e),$=e=>{const t=z[e]||[];for(let r of t)r(S[e])},_=e=>g(D,{put:(t,r)=>(r="function"==typeof r?r(e.get(t)):r,h(r)?q(e,u(e,t),r):M(e,u(e,t),{id:t,...r})),get:t=>n(u(e,t)),remove:r=>(e=>{const r=t.graph[e];t.isUpdateParents=!0;for(let n in r){if(e===n)continue;const s=t.items[n],o=t.orms[n],i=b(r[n],s,e,s.id);I(o,n,i)}U();const n=t.items[e];t.itemsMap.delete(n),t.prevItems[e]=n,t.items[e]=null,t.nextItems[e]=null,p(t.nextItems),t.isUpdateParents=!1,t.nextItems={},t.currentGraph={},t.iterationUpdates={},t.prevItems={};for(let r in t.childs[e]||{})delete t.graph[r][e];for(let r in t.graph[e]||{})delete t.childs[r][e];return delete t.ids[t.orms[e].name][d(n)],delete t.orms[e],delete t.childs[e],delete t.graph[e],G(n),t.itemsMap.delete(n),delete t.items[e],n.id})(u(e,r)),all:()=>(e=>Object.keys(t.ids[e.name]).map((t=>n(u(e,t)))))(e),loading:t=>E(u(e,t)),name:e.name}),D=[];_.enhance=e=>D.push(e);const B=(t,r,n)=>{const s=u(t,r),o=H(s);e.useEffect((()=>{const e=()=>n(H(s));return o!==H(s)&&e(),((e,t,r)=>{const n=u(e,t),s=z[n]||(z[n]=[]);s.push(r);const o=c(e,t,r);return()=>{o(),s.splice(s.indexOf(r),1)}})(t,r,e)}),[t,r,s,o,n])},H=e=>(e=>S[e])(e)||t.items[e],J=(e,t)=>{if(f(e))return t&&t.id;if(Array.isArray(e))return t.map((e=>e&&e.id));if(m(e)){if(!t)return t;let r={};for(let n in t)r[n]=J(e[n],t[n]);return r}return t};exports.door=_,exports.flat=(e,r)=>{const s=e.hasOwnProperty("all"),o=t.descFuncs[e.name](),i=n(u({name:e.name},s?r:"stone")),a=J(o,i);return s?a:a.state},exports.orm=r,exports.stone=F,exports.useDoor=(r,n)=>{const s=t.orms[r.name],o=u(s,n),[i,a]=e.useState(H(o));if(B(s,n,a),h(i))throw i;return i},exports.useStone=r=>{const n=t.orms[r.name],s=u(n,"stone"),[o,i]=e.useState(H(s));if(B(n,"stone",i),h(o))throw o.then((e=>e));return o&&o.state},exports.watch=(e,t)=>{const r=a[e.name]||(a[e.name]=[]);return r.push(t),()=>r.splice(r.indexOf(t),1)},exports.watchId=c;
